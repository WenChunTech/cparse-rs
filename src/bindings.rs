/* automatically generated by rust-bindgen 0.71.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[doc = r" If Bindgen could only determine the size and alignment of a"]
    #[doc = r" type, it is represented like this."]
    #[derive(PartialEq, Copy, Clone, Debug, Hash)]
    #[repr(C)]
    pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
    impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
        fn default() -> Self {
            Self([<T as Default>::default(); N])
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type string = root::__BindgenOpaqueArray<u64, 3usize>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct equal_to {
            pub _address: u8,
        }
        pub type equal_to___result_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less {
            pub _address: u8,
        }
        pub type less___result_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = u64;
        pub type allocator_value_type = u8;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair {
            pub _address: u8,
        }
        pub type pair_first_type = u8;
        pub type pair_second_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair__CheckArgs {
            pub _address: u8,
        }
        pub type pair__CheckArgsDep = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unique_ptr {
            pub _address: u8,
        }
        pub type unique_ptr_element_type = u8;
        pub type unique_ptr_deleter_type = u8;
        pub type unique_ptr_pointer = u8;
        pub type unique_ptr__DeleterSFINAE = u8;
        pub type unique_ptr__LValRefType = u8;
        pub type unique_ptr__GoodRValRefType = u8;
        pub type unique_ptr__BadRValRefType = u8;
        pub type unique_ptr__EnableIfDeleterDefaultConstructible = u8;
        pub type unique_ptr__EnableIfDeleterConstructible = u8;
        pub type unique_ptr__EnableIfMoveConvertible = u8;
        pub type unique_ptr__EnableIfDeleterConvertible = u8;
        pub type unique_ptr__EnableIfDeleterAssignable = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct shared_ptr {
            pub _address: u8,
        }
        pub type shared_ptr_element_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct shared_ptr___shared_ptr_default_delete {
            pub _address: u8,
        }
        pub type shared_ptr___shared_ptr_default_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type = u8;
        pub type char_traits_int_type = u32;
        pub type char_traits_off_type = u64;
        pub type char_traits_pos_type = u8;
        pub type char_traits_state_type = root::__BindgenOpaqueArray<u64, 16usize>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string {
            pub _address: u8,
        }
        pub type basic_string___default_allocator_type = u8;
        pub type basic_string___self = u8;
        pub type basic_string___self_view = u8;
        pub type basic_string_traits_type = u8;
        pub type basic_string_value_type = u8;
        pub type basic_string_allocator_type = u8;
        pub type basic_string___alloc_traits = u8;
        pub type basic_string_size_type = u8;
        pub type basic_string_reference = u8;
        pub type basic_string_const_reference = u8;
        pub type basic_string_pointer = u8;
        pub type basic_string_const_pointer = u8;
        pub type basic_string_iterator = u8;
        pub type basic_string_const_iterator = u8;
        pub type basic_string_reverse_iterator = u8;
        pub type basic_string_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string___long {
            pub _address: u8,
        }
        pub const basic_string___min_cap: root::std::basic_string__bindgen_ty_1 =
            basic_string__bindgen_ty_1::__min_cap;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum basic_string__bindgen_ty_1 {
            __min_cap = 0,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string___short {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Copy, Clone)]
        pub struct basic_string___ulx {
            pub _bindgen_opaque_blob: [u8; 0usize],
        }
        pub const basic_string___n_words: root::std::basic_string__bindgen_ty_2 =
            basic_string__bindgen_ty_2::__n_words;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum basic_string__bindgen_ty_2 {
            __n_words = 0,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string___raw {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string___rep {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Copy, Clone)]
        pub struct basic_string___rep__bindgen_ty_1 {
            pub _bindgen_opaque_blob: [u8; 0usize],
        }
        pub const basic_string___alignment: root::std::basic_string__bindgen_ty_3 =
            basic_string__bindgen_ty_3::__alignment;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum basic_string__bindgen_ty_3 {
            __alignment = 0,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct deque {
            pub _address: u8,
        }
        pub type deque_value_type = u8;
        pub type deque_allocator_type = u8;
        pub type deque___alloc_traits = u8;
        pub type deque_size_type = u8;
        pub type deque_pointer = u8;
        pub type deque_const_pointer = u8;
        pub type deque___pointer_allocator = u8;
        pub type deque___const_pointer_allocator = u8;
        pub type deque___map = u8;
        pub type deque___map_alloc_traits = u8;
        pub type deque___map_pointer = u8;
        pub type deque___map_const_pointer = u8;
        pub type deque___map_const_iterator = u8;
        pub type deque_reference = u8;
        pub type deque_const_reference = u8;
        pub type deque_iterator = u8;
        pub type deque_const_iterator = u8;
        pub type deque_reverse_iterator = u8;
        pub type deque_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct deque___deque_block_range {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct deque___deque_range {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct deque__ConstructTransaction {
            pub _address: u8,
        }
        impl root::std::deque___asan_annotation_type {
            pub const __asan_poison: root::std::deque___asan_annotation_type =
                deque___asan_annotation_type::__asan_unposion;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum deque___asan_annotation_type {
            __asan_unposion = 0,
        }
        impl root::std::deque___asan_annotation_place {
            pub const __asan_back_moved: root::std::deque___asan_annotation_place =
                deque___asan_annotation_place::__asan_front_moved;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum deque___asan_annotation_place {
            __asan_front_moved = 0,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector___default_allocator_type = u8;
        pub type vector___self = u8;
        pub type vector_value_type = u8;
        pub type vector_allocator_type = u8;
        pub type vector___alloc_traits = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_size_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector___destroy_vector {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector__ConstructTransaction {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct stack {
            pub _address: u8,
        }
        pub type stack_container_type = u8;
        pub type stack_value_type = u8;
        pub type stack_reference = u8;
        pub type stack_const_reference = u8;
        pub type stack_size_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __tree_node {
            pub _address: u8,
        }
        pub type __tree_node___node_value_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __tree_const_iterator {
            pub _address: u8,
        }
        pub type __tree_const_iterator__NodeTypes = u8;
        pub type __tree_const_iterator___node_base_pointer = u8;
        pub type __tree_const_iterator___end_node_pointer = u8;
        pub type __tree_const_iterator___iter_pointer = u8;
        pub type __tree_const_iterator___pointer_traits = u8;
        pub type __tree_const_iterator_iterator_category = u8;
        pub type __tree_const_iterator_value_type = u8;
        pub type __tree_const_iterator_reference = u8;
        pub type __tree_const_iterator_pointer = u8;
        pub type __tree_const_iterator___non_const_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __value_type {
            pub _address: u8,
        }
        pub type __value_type_key_type = u8;
        pub type __value_type_mapped_type = u8;
        pub type __value_type_value_type = u8;
        pub type __value_type___nc_ref_pair_type = u8;
        pub type __value_type___nc_rref_pair_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __map_const_iterator {
            pub _address: u8,
        }
        pub type __map_const_iterator__NodeTypes = u8;
        pub type __map_const_iterator___pointer_traits = u8;
        pub type __map_const_iterator_iterator_category = u8;
        pub type __map_const_iterator_value_type = u8;
        pub type __map_const_iterator_reference = u8;
        pub type __map_const_iterator_pointer = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map {
            pub _address: u8,
        }
        pub type map_key_type = u8;
        pub type map_mapped_type = u8;
        pub type map_value_type = u8;
        pub type map_key_compare = u8;
        pub type map_allocator_type = u8;
        pub type map_reference = u8;
        pub type map_const_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_value_compare {
            pub _address: u8,
        }
        pub type map___value_type = u8;
        pub type map___vc = u8;
        pub type map___allocator_type = u8;
        pub type map___base = u8;
        pub type map___node_traits = u8;
        pub type map___alloc_traits = u8;
        pub type map_pointer = u8;
        pub type map_const_pointer = u8;
        pub type map_size_type = u8;
        pub type map_iterator = u8;
        pub type map_const_iterator = u8;
        pub type map_reverse_iterator = u8;
        pub type map_const_reverse_iterator = u8;
        pub type map___node = u8;
        pub type map___node_allocator = u8;
        pub type map___node_base_pointer = u8;
        pub type map___parent_pointer = u8;
        pub type map__Dp = u8;
        pub type map___node_holder = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct list {
            pub _address: u8,
        }
        pub type list_base = u8;
        pub type list___node_allocator = u8;
        pub type list___node_alloc_traits = u8;
        pub type list___node_base = u8;
        pub type list___node_base_pointer = u8;
        pub type list___link_pointer = u8;
        pub type list_value_type = u8;
        pub type list_allocator_type = u8;
        pub type list_reference = u8;
        pub type list_const_reference = u8;
        pub type list_pointer = u8;
        pub type list_const_pointer = u8;
        pub type list_size_type = u8;
        pub type list_iterator = u8;
        pub type list_const_iterator = u8;
        pub type list_reverse_iterator = u8;
        pub type list_const_reverse_iterator = u8;
        pub type list___remove_return_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct set {
            pub _address: u8,
        }
        pub type set_key_type = u8;
        pub type set_value_type = u8;
        pub type set_key_compare = u8;
        pub type set_value_compare = u8;
        pub type set_allocator_type = u8;
        pub type set_reference = u8;
        pub type set_const_reference = u8;
        pub type set___base = u8;
        pub type set___alloc_traits = u8;
        pub type set_pointer = u8;
        pub type set_const_pointer = u8;
        pub type set_size_type = u8;
        pub type set_iterator = u8;
        pub type set_const_iterator = u8;
        pub type set_reverse_iterator = u8;
        pub type set_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_set {
            pub _address: u8,
        }
        pub type unordered_set_key_type = u8;
        pub type unordered_set_value_type = u8;
        pub type unordered_set_hasher = u8;
        pub type unordered_set_key_equal = u8;
        pub type unordered_set_allocator_type = u8;
        pub type unordered_set_reference = u8;
        pub type unordered_set_const_reference = u8;
        pub type unordered_set___table = u8;
        pub type unordered_set_pointer = u8;
        pub type unordered_set_const_pointer = u8;
        pub type unordered_set_size_type = u8;
        pub type unordered_set_iterator = u8;
        pub type unordered_set_const_iterator = u8;
        pub type unordered_set_local_iterator = u8;
        pub type unordered_set_const_local_iterator = u8;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct exception {
            pub _bindgen_opaque_blob: u64,
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNSt9exceptionD1Ev"]
            pub fn exception_exception_destructor(this: *mut root::std::exception);
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNKSt9exception4whatEv"]
            pub fn exception_what(this: *mut ::core::ffi::c_void) -> *const ::core::ffi::c_char;
        }
    }
    pub mod cparse {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type tokType_t = u8;
        pub type opID_t = u64;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum tokType {
            NONE = 0,
            OP = 1,
            UNARY = 2,
            VAR = 3,
            STR = 4,
            FUNC = 5,
            NUM = 32,
            REAL = 33,
            INT = 34,
            BOOL = 35,
            IT = 64,
            LIST = 65,
            TUPLE = 66,
            STUPLE = 67,
            MAP = 68,
            REF = 128,
            ANY_TYPE = 255,
        }
        #[repr(C)]
        pub struct TokenBase__bindgen_vtable {
            pub TokenBase_clone:
                unsafe extern "C" fn(this: *const TokenBase) -> *mut root::cparse::TokenBase,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct TokenBase {
            pub vtable_: *const TokenBase__bindgen_vtable,
            pub type_: root::cparse::tokType_t,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Token<T> {
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            pub _base: root::cparse::TokenBase,
            pub val: T,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct TokenNone {
            pub _base: root::cparse::TokenBase,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct TokenUnary {
            pub _base: root::cparse::TokenBase,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct TokenQueue_t {
            pub _base: root::__BindgenOpaqueArray<u64, 6usize>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct OppMap_t {
            pub RtoL: root::__BindgenOpaqueArray<u64, 3usize>,
            pub pr_map: root::__BindgenOpaqueArray<u64, 3usize>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct packToken {
            pub base: *mut root::cparse::TokenBase,
        }
        pub type packToken_strFunc_t = ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const root::cparse::TokenBase,
                arg2: u32,
            ) -> root::std::string,
        >;
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9packToken4NoneEv"]
            pub fn packToken_None() -> *const root::cparse::packToken;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9packToken10str_customEv"]
            pub fn packToken_str_custom() -> *mut root::cparse::packToken_strFunc_t;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken6asBoolEv"]
            pub fn packToken_asBool(this: *const root::cparse::packToken) -> bool;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken8asDoubleEv"]
            pub fn packToken_asDouble(this: *const root::cparse::packToken) -> f64;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken5asIntEv"]
            pub fn packToken_asInt(this: *const root::cparse::packToken) -> i64;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken8asStringEv"]
            pub fn packToken_asString(
                this: *const root::cparse::packToken,
            ) -> *mut root::std::string;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken5asMapEv"]
            pub fn packToken_asMap(
                this: *const root::cparse::packToken,
            ) -> *mut root::cparse::TokenMap;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken6asListEv"]
            pub fn packToken_asList(
                this: *const root::cparse::packToken,
            ) -> *mut root::cparse::TokenList;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken7asTupleEv"]
            pub fn packToken_asTuple(
                this: *const root::cparse::packToken,
            ) -> *mut root::cparse::Tuple;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken8asSTupleEv"]
            pub fn packToken_asSTuple(
                this: *const root::cparse::packToken,
            ) -> *mut root::cparse::STuple;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken6asFuncEv"]
            pub fn packToken_asFunc(
                this: *const root::cparse::packToken,
            ) -> *mut root::cparse::Function;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse9packToken3strEj"]
            pub fn packToken_str(
                this: *const root::cparse::packToken,
                nest: u32,
            ) -> root::std::string;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9packToken3strEPKNS_9TokenBaseEj"]
            pub fn packToken_str1(
                t: *const root::cparse::TokenBase,
                nest: u32,
            ) -> root::std::string;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9packTokenC1ERKNS_8TokenMapE"]
            pub fn packToken_packToken(
                this: *mut root::cparse::packToken,
                map: *const root::cparse::TokenMap,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9packTokenC1ERKNS_9TokenListE"]
            pub fn packToken_packToken1(
                this: *mut root::cparse::packToken,
                list: *const root::cparse::TokenList,
            );
        }
        impl packToken {
            #[inline]
            pub unsafe fn None() -> *const root::cparse::packToken {
                packToken_None()
            }
            #[inline]
            pub unsafe fn str_custom() -> *mut root::cparse::packToken_strFunc_t {
                packToken_str_custom()
            }
            #[inline]
            pub unsafe fn asBool(&self) -> bool {
                packToken_asBool(self)
            }
            #[inline]
            pub unsafe fn asDouble(&self) -> f64 {
                packToken_asDouble(self)
            }
            #[inline]
            pub unsafe fn asInt(&self) -> i64 {
                packToken_asInt(self)
            }
            #[inline]
            pub unsafe fn asString(&self) -> *mut root::std::string {
                packToken_asString(self)
            }
            #[inline]
            pub unsafe fn asMap(&self) -> *mut root::cparse::TokenMap {
                packToken_asMap(self)
            }
            #[inline]
            pub unsafe fn asList(&self) -> *mut root::cparse::TokenList {
                packToken_asList(self)
            }
            #[inline]
            pub unsafe fn asTuple(&self) -> *mut root::cparse::Tuple {
                packToken_asTuple(self)
            }
            #[inline]
            pub unsafe fn asSTuple(&self) -> *mut root::cparse::STuple {
                packToken_asSTuple(self)
            }
            #[inline]
            pub unsafe fn asFunc(&self) -> *mut root::cparse::Function {
                packToken_asFunc(self)
            }
            #[inline]
            pub unsafe fn str_(&self, nest: u32) -> root::std::string {
                packToken_str(self, nest)
            }
            #[inline]
            pub unsafe fn str1(t: *const root::cparse::TokenBase, nest: u32) -> root::std::string {
                packToken_str1(t, nest)
            }
            #[inline]
            pub unsafe fn new(map: *const root::cparse::TokenMap) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                packToken_packToken(__bindgen_tmp.as_mut_ptr(), map);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(list: *const root::cparse::TokenList) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                packToken_packToken1(__bindgen_tmp.as_mut_ptr(), list);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Container {
            pub ref_: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Iterable {
            pub _base: root::cparse::TokenBase,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Iterator {
            pub _base: root::cparse::Iterable,
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse8Iterator11getIteratorEv"]
            pub fn Iterator_getIterator(
                this: *mut ::core::ffi::c_void,
            ) -> *mut root::cparse::Iterator;
        }
        pub type TokenMap_t = root::__BindgenOpaqueArray<u64, 3usize>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct MapData_t {
            pub map: root::cparse::TokenMap_t,
            pub parent: *mut root::cparse::TokenMap,
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9MapData_tC1Ev"]
            pub fn MapData_t_MapData_t(this: *mut root::cparse::MapData_t);
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9MapData_tC1EPNS_8TokenMapE"]
            pub fn MapData_t_MapData_t1(
                this: *mut root::cparse::MapData_t,
                p: *mut root::cparse::TokenMap,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9MapData_tC1ERKS0_"]
            pub fn MapData_t_MapData_t2(
                this: *mut root::cparse::MapData_t,
                other: *const root::cparse::MapData_t,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9MapData_tD1Ev"]
            pub fn MapData_t_MapData_t_destructor(this: *mut root::cparse::MapData_t);
        }
        impl MapData_t {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                MapData_t_MapData_t(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(p: *mut root::cparse::TokenMap) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                MapData_t_MapData_t1(__bindgen_tmp.as_mut_ptr(), p);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(other: *const root::cparse::MapData_t) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                MapData_t_MapData_t2(__bindgen_tmp.as_mut_ptr(), other);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                MapData_t_MapData_t_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct TokenMap {
            pub _base: root::cparse::Container,
            pub _base_1: root::cparse::Iterable,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct TokenMap_MapIterator {
            pub _base: root::cparse::Iterator,
            pub map: *const root::cparse::TokenMap_t,
            pub it: u64,
            pub last: root::cparse::packToken,
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap5emptyE"]
            pub static mut TokenMap_empty: root::cparse::TokenMap;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap8base_mapEv"]
            pub fn TokenMap_base_map() -> *mut root::cparse::TokenMap;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap14default_globalEv"]
            pub fn TokenMap_default_global() -> *mut root::cparse::TokenMap;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap19default_constructorES0_"]
            pub fn TokenMap_default_constructor(
                scope: root::cparse::TokenMap,
            ) -> root::cparse::packToken;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap4findERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
            pub fn TokenMap_find(
                this: *mut root::cparse::TokenMap,
                key: *const root::std::string,
            ) -> *mut root::cparse::packToken;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse8TokenMap4findERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
            pub fn TokenMap_find1(
                this: *const root::cparse::TokenMap,
                key: *const root::std::string,
            ) -> *const root::cparse::packToken;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap7findMapERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
            pub fn TokenMap_findMap(
                this: *mut root::cparse::TokenMap,
                key: *const root::std::string,
            ) -> *mut root::cparse::TokenMap;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap6assignENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPNS_9TokenBaseE"]
            pub fn TokenMap_assign(
                this: *mut root::cparse::TokenMap,
                key: root::std::string,
                value: *mut root::cparse::TokenBase,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap6insertENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPNS_9TokenBaseE"]
            pub fn TokenMap_insert(
                this: *mut root::cparse::TokenMap,
                key: root::std::string,
                value: *mut root::cparse::TokenBase,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap8getChildEv"]
            pub fn TokenMap_getChild(this: *mut root::cparse::TokenMap) -> root::cparse::TokenMap;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap5eraseENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
            pub fn TokenMap_erase(this: *mut root::cparse::TokenMap, key: root::std::string);
        }
        impl TokenMap {
            #[inline]
            pub unsafe fn base_map() -> *mut root::cparse::TokenMap {
                TokenMap_base_map()
            }
            #[inline]
            pub unsafe fn default_global() -> *mut root::cparse::TokenMap {
                TokenMap_default_global()
            }
            #[inline]
            pub unsafe fn default_constructor(
                scope: root::cparse::TokenMap,
            ) -> root::cparse::packToken {
                TokenMap_default_constructor(scope)
            }
            #[inline]
            pub unsafe fn find(
                &mut self,
                key: *const root::std::string,
            ) -> *mut root::cparse::packToken {
                TokenMap_find(self, key)
            }
            #[inline]
            pub unsafe fn find1(
                &self,
                key: *const root::std::string,
            ) -> *const root::cparse::packToken {
                TokenMap_find1(self, key)
            }
            #[inline]
            pub unsafe fn findMap(
                &mut self,
                key: *const root::std::string,
            ) -> *mut root::cparse::TokenMap {
                TokenMap_findMap(self, key)
            }
            #[inline]
            pub unsafe fn assign(
                &mut self,
                key: root::std::string,
                value: *mut root::cparse::TokenBase,
            ) {
                TokenMap_assign(self, key, value)
            }
            #[inline]
            pub unsafe fn insert(
                &mut self,
                key: root::std::string,
                value: *mut root::cparse::TokenBase,
            ) {
                TokenMap_insert(self, key, value)
            }
            #[inline]
            pub unsafe fn getChild(&mut self) -> root::cparse::TokenMap {
                TokenMap_getChild(self)
            }
            #[inline]
            pub unsafe fn erase(&mut self, key: root::std::string) {
                TokenMap_erase(self, key)
            }
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap11MapIterator4nextEv"]
            pub fn TokenMap_MapIterator_next(
                this: *mut ::core::ffi::c_void,
            ) -> *mut root::cparse::packToken;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8TokenMap11MapIterator5resetEv"]
            pub fn TokenMap_MapIterator_reset(this: *mut ::core::ffi::c_void);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GlobalScope {
            pub _base: root::cparse::TokenMap,
        }
        pub type TokenList_t = root::__BindgenOpaqueArray<u64, 3usize>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct TokenList {
            pub _base: root::cparse::Container,
            pub _base_1: root::cparse::Iterable,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct TokenList_ListIterator {
            pub _base: root::cparse::Iterator,
            pub list: *mut root::cparse::TokenList_t,
            pub i: usize,
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9TokenList19default_constructorENS_8TokenMapE"]
            pub fn TokenList_default_constructor(
                scope: root::cparse::TokenMap,
            ) -> root::cparse::packToken;
        }
        impl TokenList {
            #[inline]
            pub unsafe fn default_constructor(
                scope: root::cparse::TokenMap,
            ) -> root::cparse::packToken {
                TokenList_default_constructor(scope)
            }
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9TokenList12ListIterator4nextEv"]
            pub fn TokenList_ListIterator_next(
                this: *mut ::core::ffi::c_void,
            ) -> *mut root::cparse::packToken;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9TokenList12ListIterator5resetEv"]
            pub fn TokenList_ListIterator_reset(this: *mut ::core::ffi::c_void);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Tuple {
            pub _base: root::cparse::TokenList,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct STuple {
            pub _base: root::cparse::Tuple,
        }
        pub type args_t = root::__BindgenOpaqueArray<u64, 3usize>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct Function {
            pub _base: root::cparse::TokenBase,
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse8Function4callENS_9packTokenEPKS0_PNS_9TokenListENS_8TokenMapE"]
            pub fn Function_call(
                _this: root::cparse::packToken,
                func: *const root::cparse::Function,
                args: *mut root::cparse::TokenList,
                scope: root::cparse::TokenMap,
            ) -> root::cparse::packToken;
        }
        impl Function {
            #[inline]
            pub unsafe fn call(
                _this: root::cparse::packToken,
                func: *const root::cparse::Function,
                args: *mut root::cparse::TokenList,
                scope: root::cparse::TokenMap,
            ) -> root::cparse::packToken {
                Function_call(_this, func, args, scope)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CppFunction {
            pub _base: root::cparse::Function,
            pub func: ::core::option::Option<
                unsafe extern "C" fn(arg1: root::cparse::TokenMap) -> root::cparse::packToken,
            >,
            pub stdFunc: root::__BindgenOpaqueArray<u64, 4usize>,
            pub _args: root::cparse::args_t,
            pub _name: root::std::string,
            pub isStdFunc: bool,
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse11CppFunctionC1Ev"]
            pub fn CppFunction_CppFunction(this: *mut root::cparse::CppFunction);
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse11CppFunctionC1EPFNS_9packTokenENS_8TokenMapEENSt3__14listINS5_12basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENSA_ISC_EEEESC_"]
            pub fn CppFunction_CppFunction1(
                this: *mut root::cparse::CppFunction,
                func: ::core::option::Option<
                    unsafe extern "C" fn(arg1: root::cparse::TokenMap) -> root::cparse::packToken,
                >,
                args: root::cparse::args_t,
                name: root::std::string,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse11CppFunctionC1EPFNS_9packTokenENS_8TokenMapEEjPPKcNSt3__112basic_stringIcNS8_11char_traitsIcEENS8_9allocatorIcEEEE"]
            pub fn CppFunction_CppFunction2(
                this: *mut root::cparse::CppFunction,
                func: ::core::option::Option<
                    unsafe extern "C" fn(arg1: root::cparse::TokenMap) -> root::cparse::packToken,
                >,
                nargs: ::core::ffi::c_uint,
                args: *mut *const ::core::ffi::c_char,
                name: root::std::string,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse11CppFunctionC1EPFNS_9packTokenENS_8TokenMapEENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEE"]
            pub fn CppFunction_CppFunction3(
                this: *mut root::cparse::CppFunction,
                func: ::core::option::Option<
                    unsafe extern "C" fn(arg1: root::cparse::TokenMap) -> root::cparse::packToken,
                >,
                name: root::std::string,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse11CppFunctionC1ENSt3__18functionIFNS_9packTokenENS_8TokenMapEEEENS1_4listINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENSB_ISD_EEEESD_"]
            pub fn CppFunction_CppFunction4(
                this: *mut root::cparse::CppFunction,
                func: root::__BindgenOpaqueArray<u64, 4usize>,
                args: root::cparse::args_t,
                name: root::std::string,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse11CppFunctionC1ENSt3__14listINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEENS1_8functionIFNS_9packTokenENS_8TokenMapEEEES8_"]
            pub fn CppFunction_CppFunction5(
                this: *mut root::cparse::CppFunction,
                args: root::cparse::args_t,
                func: root::__BindgenOpaqueArray<u64, 4usize>,
                name: root::std::string,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse11CppFunctionC1ENSt3__18functionIFNS_9packTokenENS_8TokenMapEEEEjPPKcNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
            pub fn CppFunction_CppFunction6(
                this: *mut root::cparse::CppFunction,
                func: root::__BindgenOpaqueArray<u64, 4usize>,
                nargs: ::core::ffi::c_uint,
                args: *mut *const ::core::ffi::c_char,
                name: root::std::string,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse11CppFunctionC1ENSt3__18functionIFNS_9packTokenENS_8TokenMapEEEENS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
            pub fn CppFunction_CppFunction7(
                this: *mut root::cparse::CppFunction,
                func: root::__BindgenOpaqueArray<u64, 4usize>,
                name: root::std::string,
            );
        }
        impl CppFunction {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                CppFunction_CppFunction(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                func: ::core::option::Option<
                    unsafe extern "C" fn(arg1: root::cparse::TokenMap) -> root::cparse::packToken,
                >,
                args: root::cparse::args_t,
                name: root::std::string,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                CppFunction_CppFunction1(__bindgen_tmp.as_mut_ptr(), func, args, name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(
                func: ::core::option::Option<
                    unsafe extern "C" fn(arg1: root::cparse::TokenMap) -> root::cparse::packToken,
                >,
                nargs: ::core::ffi::c_uint,
                args: *mut *const ::core::ffi::c_char,
                name: root::std::string,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                CppFunction_CppFunction2(__bindgen_tmp.as_mut_ptr(), func, nargs, args, name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new3(
                func: ::core::option::Option<
                    unsafe extern "C" fn(arg1: root::cparse::TokenMap) -> root::cparse::packToken,
                >,
                name: root::std::string,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                CppFunction_CppFunction3(__bindgen_tmp.as_mut_ptr(), func, name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new4(
                func: root::__BindgenOpaqueArray<u64, 4usize>,
                args: root::cparse::args_t,
                name: root::std::string,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                CppFunction_CppFunction4(__bindgen_tmp.as_mut_ptr(), func, args, name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new5(
                args: root::cparse::args_t,
                func: root::__BindgenOpaqueArray<u64, 4usize>,
                name: root::std::string,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                CppFunction_CppFunction5(__bindgen_tmp.as_mut_ptr(), args, func, name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new6(
                func: root::__BindgenOpaqueArray<u64, 4usize>,
                nargs: ::core::ffi::c_uint,
                args: *mut *const ::core::ffi::c_char,
                name: root::std::string,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                CppFunction_CppFunction6(__bindgen_tmp.as_mut_ptr(), func, nargs, args, name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new7(
                func: root::__BindgenOpaqueArray<u64, 4usize>,
                name: root::std::string,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                CppFunction_CppFunction7(__bindgen_tmp.as_mut_ptr(), func, name);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct rpnBuilder {
            pub rpn: root::cparse::TokenQueue_t,
            pub opStack: root::__BindgenOpaqueArray<u64, 6usize>,
            pub lastTokenWasOp: u8,
            pub lastTokenWasUnary: bool,
            pub scope: root::cparse::TokenMap,
            pub opp: *const root::cparse::OppMap_t,
            pub bracketLevel: u32,
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10rpnBuilder8cleanRPNEPNS_12TokenQueue_tE"]
            pub fn rpnBuilder_cleanRPN(rpn: *mut root::cparse::TokenQueue_t);
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10rpnBuilder9handle_opERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
            pub fn rpnBuilder_handle_op(
                this: *mut root::cparse::rpnBuilder,
                op: *const root::std::string,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10rpnBuilder12handle_tokenEPNS_9TokenBaseE"]
            pub fn rpnBuilder_handle_token(
                this: *mut root::cparse::rpnBuilder,
                token: *mut root::cparse::TokenBase,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10rpnBuilder12open_bracketERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
            pub fn rpnBuilder_open_bracket(
                this: *mut root::cparse::rpnBuilder,
                bracket: *const root::std::string,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10rpnBuilder13close_bracketERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
            pub fn rpnBuilder_close_bracket(
                this: *mut root::cparse::rpnBuilder,
                bracket: *const root::std::string,
            );
        }
        impl rpnBuilder {
            #[inline]
            pub unsafe fn cleanRPN(rpn: *mut root::cparse::TokenQueue_t) {
                rpnBuilder_cleanRPN(rpn)
            }
            #[inline]
            pub unsafe fn handle_op(&mut self, op: *const root::std::string) {
                rpnBuilder_handle_op(self, op)
            }
            #[inline]
            pub unsafe fn handle_token(&mut self, token: *mut root::cparse::TokenBase) {
                rpnBuilder_handle_token(self, token)
            }
            #[inline]
            pub unsafe fn open_bracket(&mut self, bracket: *const root::std::string) {
                rpnBuilder_open_bracket(self, bracket)
            }
            #[inline]
            pub unsafe fn close_bracket(&mut self, bracket: *const root::std::string) {
                rpnBuilder_close_bracket(self, bracket)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct evaluationData {
            pub rpn: root::cparse::TokenQueue_t,
            pub scope: root::cparse::TokenMap,
            pub opMap: *const root::cparse::opMap_t,
            pub left: u64,
            pub right: u64,
            pub op: root::std::string,
            pub opID: root::cparse::opID_t,
        }
        pub type rWordParser_t = ::core::option::Option<
            unsafe extern "C" fn(
                expr: *const ::core::ffi::c_char,
                rest: *mut *const ::core::ffi::c_char,
                data: *mut root::cparse::rpnBuilder,
            ),
        >;
        pub type rWordMap_t = root::__BindgenOpaqueArray<u64, 3usize>;
        pub type rCharMap_t = root::__BindgenOpaqueArray<u64, 3usize>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct parserMap_t {
            pub wmap: root::cparse::rWordMap_t,
            pub cmap: root::cparse::rCharMap_t,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct RefToken {
            pub _base: root::cparse::TokenBase,
            pub original_value: root::cparse::packToken,
            pub key: root::cparse::packToken,
            pub origin: root::cparse::packToken,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct opSignature_t {
            pub left: root::cparse::tokType_t,
            pub op: root::std::string,
            pub right: root::cparse::tokType_t,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Operation {
            pub _mask: root::cparse::opID_t,
            pub _exec: root::cparse::Operation_opFunc_t,
        }
        pub type Operation_opFunc_t = ::core::option::Option<
            unsafe extern "C" fn(
                left: *const root::cparse::packToken,
                right: *const root::cparse::packToken,
                data: *mut root::cparse::evaluationData,
            ) -> root::cparse::packToken,
        >;
        #[repr(C)]
        #[derive(Debug)]
        pub struct Operation_Reject {
            pub _base: root::std::exception,
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse9Operation10build_maskEhh"]
            pub fn Operation_build_mask(
                left: root::cparse::tokType_t,
                right: root::cparse::tokType_t,
            ) -> root::cparse::opID_t;
        }
        impl Operation {
            #[inline]
            pub unsafe fn build_mask(
                left: root::cparse::tokType_t,
                right: root::cparse::tokType_t,
            ) -> root::cparse::opID_t {
                Operation_build_mask(left, right)
            }
        }
        pub type typeMap_t = u8;
        pub type opList_t = root::__BindgenOpaqueArray<u64, 3usize>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct opMap_t {
            pub _base: root::__BindgenOpaqueArray<u64, 3usize>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Config_t {
            pub parserMap: root::cparse::parserMap_t,
            pub opPrecedence: root::cparse::OppMap_t,
            pub opMap: root::cparse::opMap_t,
        }
        #[repr(C)]
        pub struct calculator__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct calculator {
            pub vtable_: *const calculator__bindgen_vtable,
            pub RPN: root::cparse::TokenQueue_t,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct calculator_RAII_TokenQueue_t {
            _unused: [u8; 0],
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculator7DefaultEv"]
            pub fn calculator_Default() -> *mut root::cparse::Config_t;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculator18type_attribute_mapEv"]
            pub fn calculator_type_attribute_map() -> *mut root::cparse::typeMap_t;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculator9calculateEPKcNS_8TokenMapES2_PS2_"]
            pub fn calculator_calculate(
                expr: *const ::core::ffi::c_char,
                vars: root::cparse::TokenMap,
                delim: *const ::core::ffi::c_char,
                rest: *mut *const ::core::ffi::c_char,
            ) -> root::cparse::packToken;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculator9calculateERKNS_12TokenQueue_tENS_8TokenMapERKNS_8Config_tE"]
            pub fn calculator_calculate1(
                RPN: *const root::cparse::TokenQueue_t,
                scope: root::cparse::TokenMap,
                config: *const root::cparse::Config_t,
            ) -> *mut root::cparse::TokenBase;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculator5toRPNEPKcNS_8TokenMapES2_PS2_NS_8Config_tE"]
            pub fn calculator_toRPN(
                expr: *const ::core::ffi::c_char,
                vars: root::cparse::TokenMap,
                delim: *const ::core::ffi::c_char,
                rest: *mut *const ::core::ffi::c_char,
                config: root::cparse::Config_t,
            ) -> root::cparse::TokenQueue_t;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculator7compileEPKcNS_8TokenMapES2_PS2_"]
            pub fn calculator_compile(
                this: *mut root::cparse::calculator,
                expr: *const ::core::ffi::c_char,
                vars: root::cparse::TokenMap,
                delim: *const ::core::ffi::c_char,
                rest: *mut *const ::core::ffi::c_char,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse10calculator4evalENS_8TokenMapEb"]
            pub fn calculator_eval(
                this: *const root::cparse::calculator,
                vars: root::cparse::TokenMap,
                keep_refs: bool,
            ) -> root::cparse::packToken;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse10calculator13get_variablesEv"]
            pub fn calculator_get_variables(this: *const root::cparse::calculator) -> u8;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZNK6cparse10calculator3strEv"]
            pub fn calculator_str(this: *const root::cparse::calculator) -> root::std::string;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculator3strENS_12TokenQueue_tE"]
            pub fn calculator_str1(rpn: root::cparse::TokenQueue_t) -> root::std::string;
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculatorC1ERKS0_"]
            pub fn calculator_calculator(
                this: *mut root::cparse::calculator,
                calc: *const root::cparse::calculator,
            );
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculatorC1EPKcNS_8TokenMapES2_PS2_RKNS_8Config_tE"]
            pub fn calculator_calculator1(
                this: *mut root::cparse::calculator,
                expr: *const ::core::ffi::c_char,
                vars: root::cparse::TokenMap,
                delim: *const ::core::ffi::c_char,
                rest: *mut *const ::core::ffi::c_char,
                config: *const root::cparse::Config_t,
            );
        }
        impl calculator {
            #[inline]
            pub unsafe fn Default() -> *mut root::cparse::Config_t {
                calculator_Default()
            }
            #[inline]
            pub unsafe fn type_attribute_map() -> *mut root::cparse::typeMap_t {
                calculator_type_attribute_map()
            }
            #[inline]
            pub unsafe fn calculate(
                expr: *const ::core::ffi::c_char,
                vars: root::cparse::TokenMap,
                delim: *const ::core::ffi::c_char,
                rest: *mut *const ::core::ffi::c_char,
            ) -> root::cparse::packToken {
                calculator_calculate(expr, vars, delim, rest)
            }
            #[inline]
            pub unsafe fn calculate1(
                RPN: *const root::cparse::TokenQueue_t,
                scope: root::cparse::TokenMap,
                config: *const root::cparse::Config_t,
            ) -> *mut root::cparse::TokenBase {
                calculator_calculate1(RPN, scope, config)
            }
            #[inline]
            pub unsafe fn toRPN(
                expr: *const ::core::ffi::c_char,
                vars: root::cparse::TokenMap,
                delim: *const ::core::ffi::c_char,
                rest: *mut *const ::core::ffi::c_char,
                config: root::cparse::Config_t,
            ) -> root::cparse::TokenQueue_t {
                calculator_toRPN(expr, vars, delim, rest, config)
            }
            #[inline]
            pub unsafe fn compile(
                &mut self,
                expr: *const ::core::ffi::c_char,
                vars: root::cparse::TokenMap,
                delim: *const ::core::ffi::c_char,
                rest: *mut *const ::core::ffi::c_char,
            ) {
                calculator_compile(self, expr, vars, delim, rest)
            }
            #[inline]
            pub unsafe fn eval(
                &self,
                vars: root::cparse::TokenMap,
                keep_refs: bool,
            ) -> root::cparse::packToken {
                calculator_eval(self, vars, keep_refs)
            }
            #[inline]
            pub unsafe fn get_variables(&self) -> u8 {
                calculator_get_variables(self)
            }
            #[inline]
            pub unsafe fn str_(&self) -> root::std::string {
                calculator_str(self)
            }
            #[inline]
            pub unsafe fn str1(rpn: root::cparse::TokenQueue_t) -> root::std::string {
                calculator_str1(rpn)
            }
            #[inline]
            pub unsafe fn new(calc: *const root::cparse::calculator) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                calculator_calculator(__bindgen_tmp.as_mut_ptr(), calc);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                expr: *const ::core::ffi::c_char,
                vars: root::cparse::TokenMap,
                delim: *const ::core::ffi::c_char,
                rest: *mut *const ::core::ffi::c_char,
                config: *const root::cparse::Config_t,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                calculator_calculator1(__bindgen_tmp.as_mut_ptr(), expr, vars, delim, rest, config);
                __bindgen_tmp.assume_init()
            }
        }
        unsafe extern "C" {
            #[link_name = "\u{1}__ZN6cparse10calculatorD1Ev"]
            pub fn calculator_calculator_destructor(this: *mut root::cparse::calculator);
        }
    }
}
